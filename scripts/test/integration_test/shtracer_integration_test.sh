#!/bin/sh

# Integration tests for shtracer
# Tests end-to-end functionality with real configuration and data

SCRIPT_DIR=$(CDPATH='' cd -- "$(dirname -- "$0")" 2>/dev/null && pwd -P)
TEST_ROOT=${TEST_ROOT:-$(CDPATH='' cd -- "${SCRIPT_DIR%/}/.." 2>/dev/null && pwd -P)}
SHTRACER_ROOT_DIR=${SHTRACER_ROOT_DIR:-$(CDPATH='' cd -- "${TEST_ROOT%/}/../.." 2>/dev/null && pwd -P)}

SHTRACER_BIN="${SHTRACER_ROOT_DIR%/}/shtracer"
SHTRACER_VIEWER="${SHTRACER_ROOT_DIR%/}/scripts/main/shtracer_html_viewer.sh"
TEST_DATA_DIR="${SCRIPT_DIR%/}/testdata"
ANSWER_DIR="${SCRIPT_DIR%/}/testdata/expected"

##
# @brief
#
oneTimeSetUp() {
	echo "----------------------------------------"
	echo " INTEGRATION TEST : $0"
	echo "----------------------------------------"
}

##
# @brief  SetUp function for each test
#
setUp() {
	set +u
	cd "${TEST_DATA_DIR}" || exit 1
	# Clean up any previous output
	rm -rf output/
}

##
# @brief TearDown function for each test
#
tearDown() {
	# Clean up output after each test
	rm -rf "${TEST_DATA_DIR}/shtracer_output/"
}

##
# @brief  Integration test for normal mode
# @tag    @IT1.1@ (FROM: @UT1.18@)
test_integration_normal_mode() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		"${SHTRACER_BIN}" ./config_integration.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Shtracer should exit successfully" 0 "${_EXIT_CODE}"

		# Check output files exist
		assertTrue "Config table should exist" "[ -f shtracer_output/config/01_config_table ]"
		assertTrue "Tags file should exist" "[ -f shtracer_output/tags/01_tags ]"
		assertTrue "Tag table should exist" "[ -f shtracer_output/tags/04_tag_table ]"
		assertTrue "JSON output should exist" "[ -f shtracer_output/output.json ]"
		assertTrue "HTML should not be generated by backend" "[ ! -f shtracer_output/output.html ]"

		# Verify tag table content
		# Note: String comparison may fail on Windows due to CRLF vs LF differences
		# Skip exact match test on Windows, but verify basic structure
		_TAG_TABLE=$(cat shtracer_output/tags/04_tag_table)
		_EXPECTED=$(cat "${ANSWER_DIR}/tag_table_expected.txt")

		# Normalize line endings for cross-platform compatibility
		_TAG_TABLE_NORM=$(printf '%s' "${_TAG_TABLE}" | tr -d '\r')
		_EXPECTED_NORM=$(printf '%s' "${_EXPECTED}" | tr -d '\r')

		assertEquals "Tag table should match expected output" "${_EXPECTED_NORM}" "${_TAG_TABLE_NORM}"

		# Generate HTML via viewer (stdin JSON -> stdout HTML)
		"${SHTRACER_VIEWER}" <shtracer_output/output.json >shtracer_output/output.html
		assertEquals "Viewer should exit successfully" 0 $?
		assertTrue "HTML output should exist" "[ -f shtracer_output/output.html ]"

		# Check HTML is valid (contains basic structure)
		grep -q "<!DOCTYPE html>" shtracer_output/output.html
		assertEquals "HTML should have DOCTYPE" 0 $?

		grep -q "<table" shtracer_output/output.html
		assertEquals "HTML should contain table" 0 $?

		# Check D3.js and Sankey elements
		grep -q "d3js.org" shtracer_output/output.html
		assertEquals "HTML should include D3.js" 0 $?

		grep -q "sankey-diagram" shtracer_output/output.html
		assertEquals "HTML should contain Sankey diagram container" 0 $?

		# Single-file: assets should be inlined
		grep -q "const files =" shtracer_output/output.html
		assertEquals "HTML should inline show_text.js data" 0 $?
		grep -q "traceabilityData" shtracer_output/output.html
		assertEquals "HTML should include embedded JSON" 0 $?

		# Check JSON structure
		grep -q '"metadata"' shtracer_output/output.json
		assertEquals "JSON should contain metadata" 0 $?
		grep -q '"files"' shtracer_output/output.json
		assertEquals "JSON should contain files" 0 $?
		grep -q '"layers"' shtracer_output/output.json
		assertEquals "JSON should contain layers" 0 $?
		grep -q '"trace_tags"' shtracer_output/output.json
		assertEquals "JSON should contain trace_tags" 0 $?
		grep -q '"chains"' shtracer_output/output.json
		assertEquals "JSON should contain chains" 0 $?
		grep -q '"health"' shtracer_output/output.json
		assertEquals "JSON should contain health" 0 $?
	)
}

##
# @brief  Output directory should be removed on normal exit (non-debug)
# @tag    @IT1.cleanup.1@
test_integration_cleanup_normal_exit() {
	(
		cd "${TEST_DATA_DIR}" || exit 1
		rm -rf shtracer_output/

		"${SHTRACER_BIN}" ./config_integration.md >/dev/null 2>&1
		_EXIT_CODE=$?
		assertEquals "Shtracer should exit successfully" 0 "${_EXIT_CODE}"
		assertFalse "Output dir should be removed on normal exit" "[ -d shtracer_output ]"
	)
}

##
# @brief  Integration test for --html (stdout HTML)
# @tag    @IT1.1a@ (FROM: @UT1.18@)
test_integration_html_option() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1
		rm -rf output
		mkdir -p output

		# Act -------------
		"${SHTRACER_BIN}" ./config_integration.md --debug --html >output/output.html 2>/dev/null
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Shtracer --html should exit successfully" 0 "${_EXIT_CODE}"
		assertTrue "JSON output should exist" "[ -f shtracer_output/output.json ]"
		assertTrue "HTML output should exist" "[ -f output/output.html ]"
		grep -q "<!DOCTYPE html>" output/output.html
		assertEquals "HTML should have DOCTYPE" 0 $?
		grep -q "traceabilityData" output/output.html
		assertEquals "HTML should include embedded JSON" 0 $?
	)
}

##
# @brief  Integration test for verify mode
# @tag    @IT1.2@ (FROM: @UT1.18@)
test_integration_verify_mode() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		_OUTPUT=$("${SHTRACER_BIN}" ./config_integration.md --debug -v 2>&1)
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Verify mode should exit successfully with valid data" 0 "${_EXIT_CODE}"

		# HTML should NOT be generated in verify mode
		assertFalse "HTML should not exist in verify mode" "[ -f shtracer_output/output.html ]"

		# Tag table should still be generated
		assertTrue "Tag table should exist in verify mode" "[ -f shtracer_output/tags/04_tag_table ]"
	)
}

##
# @brief  Integration test for change mode
# @tag    @IT1.3@ (FROM: @UT1.18@)
test_integration_change_mode() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Create a temporary copy of the test file
		cp req_sample.md req_sample_temp.md

		# Act -------------
		# Create a simple config that points to the temp file
		cat >config_temp.md <<'EOF'
# Temp Config

## Requirements

* **PATH**: "./req_sample_temp.md"
  * **BRIEF**: "Temporary requirements"
  * **TAG FORMAT**: `@REQ[0-9\.]+@`
  * **TAG LINE FORMAT**: `<!--.*-->`
  * **TAG-TITLE OFFSET**: 1
EOF

		"${SHTRACER_BIN}" ./config_temp.md -c "@REQ1.1@" "@REQ2.1@" >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Change mode should exit successfully" 0 "${_EXIT_CODE}"

		# Check that the tag was changed
		grep -q "@REQ2.1@" req_sample_temp.md
		assertEquals "Tag should be changed to @REQ2.1@" 0 $?

		grep -q "@REQ1.1@" req_sample_temp.md
		assertNotEquals "Original tag @REQ1.1@ should not exist" 0 $?

		# Clean up
		rm -f req_sample_temp.md config_temp.md
	)
}

##
# @brief  Integration test for multi-file traceability
# @tag    @IT1.4@ (FROM: @UT1.18@)
test_integration_multiple_files() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		"${SHTRACER_BIN}" ./config_integration.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Multi-file test should exit successfully" 0 "${_EXIT_CODE}"

		_TAG_TABLE=$(cat shtracer_output/tags/04_tag_table)

		# Verify complete traceability chains exist
		echo "${_TAG_TABLE}" | grep -q "@REQ1.1@ @ARC1.1@ @IMP1.1@"
		assertEquals "Complete chain REQ->ARC->IMP should exist for requirement 1.1" 0 $?

		echo "${_TAG_TABLE}" | grep -q "@REQ1.2@ @ARC1.2@ @IMP1.2@"
		assertEquals "Complete chain REQ->ARC->IMP should exist for requirement 1.2" 0 $?

		echo "${_TAG_TABLE}" | grep -q "@REQ1.3@ @ARC1.3@ @IMP1.3@"
		assertEquals "Complete chain REQ->ARC->IMP should exist for requirement 1.3" 0 $?

		# Count total chains (strip whitespace for BSD wc compatibility)
		_CHAIN_COUNT=$(echo "${_TAG_TABLE}" | wc -l | tr -d ' \t')
		assertEquals "Should have exactly 3 traceability chains" 3 "${_CHAIN_COUNT}"
	)
}

##
# @brief  Output directory should be removed on signal (non-debug)
# @tag    @IT1.cleanup.2@
test_integration_cleanup_sigint() {
	cd "${TEST_DATA_DIR}" || exit 1
	rm -rf shtracer_output/

	SHTRACER_TEST_HOLD_SECS=10 "${SHTRACER_BIN}" ./config_integration.md >/dev/null 2>&1 &
	_PID=$!

	# Wait (up to ~5s) for output dir to appear
	_i=0
	while [ $_i -lt 5 ] && [ ! -d shtracer_output ]; do
		sleep 1
		_i=$((_i + 1))
	done
	assertTrue "Output dir should exist before SIGINT" "[ -d shtracer_output ]"

	kill -TERM "${_PID}" >/dev/null 2>&1 || :
	wait "${_PID}"
	_RC=$?
	assertNotEquals "Process should not exit 0 on signal" 0 "${_RC}"
	assertFalse "Output dir should be removed on signal" "[ -d shtracer_output ]"
}

##
# @brief  Integration test for error handling
# @tag    @IT1.5@ (FROM: @UT1.18@)
test_integration_error_handling() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Create config with non-existent path
		cat >config_error.md <<'EOF'
# Error Config

## NonExistent

* **PATH**: "./non_existent_file.md"
  * **BRIEF**: "This file does not exist"
  * **TAG FORMAT**: `@TEST[0-9\.]+@`
  * **TAG LINE FORMAT**: `<!--.*-->`
  * **TAG-TITLE OFFSET**: 1
EOF

		# Act -------------
		_OUTPUT=$("${SHTRACER_BIN}" ./config_error.md 2>&1)
		_EXIT_CODE=$?

		# Assert ----------
		assertNotEquals "Shtracer should exit with error for non-existent file" 0 "${_EXIT_CODE}"

		# Error message should be present
		echo "${_OUTPUT}" | grep -q "error\|Error\|No linked tags"
		assertEquals "Error message should be present" 0 $?

		# Clean up
		rm -f config_error.md
	)
}

##
# @brief  Integration test for default JSON export
# @tag    @IT2.1@ (FROM: @UT1.18@)
test_integration_json_export() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		_OUTPUT=$("${SHTRACER_BIN}" ./config_integration.md 2>&1)
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Shtracer should exit successfully with default JSON output" 0 "${_EXIT_CODE}"

		# Verify JSON is output to stdout by default (v0.2.0 format)
		echo "${_OUTPUT}" | grep -q '"metadata"'
		assertEquals "JSON should contain metadata" 0 $?

		echo "${_OUTPUT}" | grep -q '"trace_tags"'
		assertEquals "JSON should contain trace_tags" 0 $?

		echo "${_OUTPUT}" | grep -q '"files"'
		assertEquals "JSON should contain files" 0 $?

		echo "${_OUTPUT}" | grep -q '"chains"'
		assertEquals "JSON should contain chains" 0 $?

		# HTML should NOT be generated by default
		assertTrue "HTML should not be generated by default" "[ ! -f output/output.html ]"
	)
}

##
# @brief  Integration test for summary export
test_integration_summary_export() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		_OUTPUT=$("${SHTRACER_BIN}" ./config_integration.md --summary 2>&1)
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Shtracer should exit successfully with summary" 0 "${_EXIT_CODE}"

		# Basic format checks
		echo "${_OUTPUT}" | grep -q "^Requirement$\|^Architecture$\|^Implementation$\|^Unit test$\|^Integration test$"
		assertEquals "Summary should contain layer headers" 0 $?
		echo "${_OUTPUT}" | grep -q "^  upstream: \|^  downstream: "
		assertEquals "Summary should contain upstream/downstream lines" 0 $?
		echo "${_OUTPUT}" | grep -q "%$\|<1%"
		assertEquals "Summary should contain percentage tokens" 0 $?

		# HTML/JSON should NOT be generated in summary mode
		assertTrue "HTML should not be generated with --summary" "[ ! -f output/output.html ]"
		assertTrue "JSON should not be generated with --summary" "[ ! -f output/output.json ]"
	)
}

##
# @brief  Integration test for --html before config (flexible order)
# @tag    @IT1.6@ (FROM: @UT1.25@)
test_integration_html_flexible_order() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1
		_OUTPUT_HTML="${SHUNIT_TMPDIR%/}/shtracer_html_flexible_order.html"
		rm -f "${_OUTPUT_HTML}"

		# Act -------------
		# New order: --html first
		"${SHTRACER_BIN}" --html ./config_integration.md >"${_OUTPUT_HTML}" 2>/dev/null
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "HTML export with --html before config should succeed" 0 "${_EXIT_CODE}"

		assertTrue "HTML output should exist" "[ -f '${_OUTPUT_HTML}' ]"

		# Check HTML is valid
		grep -q "<!DOCTYPE html>" "${_OUTPUT_HTML}"
		assertEquals "HTML should have DOCTYPE" 0 $?

		grep -q "<table" "${_OUTPUT_HTML}"
		assertEquals "HTML should contain table" 0 $?

		grep -q "d3js.org" "${_OUTPUT_HTML}"
		assertEquals "HTML should include D3.js" 0 $?
	)
}

##
# @brief  Integration test for -v before config (flexible order)
# @tag    @IT1.7@ (FROM: @UT1.26@)
test_integration_verify_flexible_order() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		# New order: -v first
		_OUTPUT=$("${SHTRACER_BIN}" -v ./config_integration.md 2>&1)
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Verify mode with -v before config should succeed" 0 "${_EXIT_CODE}"

		# Output should be empty on success (no duplicates/isolated tags)
		# or should contain verification messages if issues found
		# For this test data, we expect success with minimal output
	)
}

##
# @brief  Test that cross-reference matrix files are generated
# @tag    @IT1.8@ (FROM: @IMP4.4@)
test_cross_ref_matrix_files_generated() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		"${SHTRACER_BIN}" ./config_integration.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Shtracer should exit successfully" 0 "${_EXIT_CODE}"

		# Check that cross-reference matrix files exist
		_MATRIX_FILES=$(find shtracer_output/tags -name "06_cross_ref_matrix_*" 2>/dev/null | wc -l | tr -d ' \t')
		assertTrue "At least one cross-reference matrix file should exist" "[ ${_MATRIX_FILES} -gt 0 ]"

		# Verify matrix file format
		_FIRST_MATRIX=$(find shtracer_output/tags -name "06_cross_ref_matrix_*" 2>/dev/null | head -1)
		if [ -n "${_FIRST_MATRIX}" ]; then
			grep -q "^\[METADATA\]" "${_FIRST_MATRIX}"
			assertEquals "Matrix file should have METADATA section" 0 $?

			grep -q "^\[MATRIX\]" "${_FIRST_MATRIX}"
			assertEquals "Matrix file should have MATRIX section" 0 $?
		fi
	)
}

##
# @brief  Test that HTML viewer displays cross-reference tables
# @tag    @IT1.9@ (FROM: @IMP4.4@)
test_html_cross_ref_tables() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		"${SHTRACER_BIN}" ./config_integration.md --debug >/dev/null 2>&1
		"${SHTRACER_VIEWER}" <shtracer_output/output.json >shtracer_output/output.html 2>&1

		# Assert ----------
		assertTrue "HTML output should exist" "[ -f shtracer_output/output.html ]"

		# Check for cross-reference matrix tabs
		_XREF_TABS=$(grep -c "matrix-tab" shtracer_output/output.html || echo "0")
		assertTrue "HTML should contain cross-reference matrix tabs" "[ ${_XREF_TABS} -gt 0 ]"

		# Verify that tables are not empty (should contain matrix-table class)
		grep -q "matrix-table" shtracer_output/output.html
		assertEquals "HTML should contain cross-reference matrix tables" 0 $?
	)
}

##
# @brief  Test that markdown viewer shows populated tag index
# @tag    @IT1.10@ (FROM: @IMP4.3.10.2@)
test_markdown_tag_index() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1
		mkdir -p shtracer_output

		# Act -------------
		"${SHTRACER_BIN}" --debug --markdown ./config_integration.md >shtracer_output/output.md 2>&1
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Markdown mode should exit successfully" 0 "${_EXIT_CODE}"

		# Check for tag index section
		grep -q "^## Tag Index" shtracer_output/output.md
		assertEquals "Markdown should have Tag Index section" 0 $?

		# Verify that tag index has actual tag entries (not just "****")
		_TAG_ENTRIES=$(grep -c "^- \*\*@" shtracer_output/output.md || echo "0")
		assertTrue "Tag index should have actual tag entries" "[ ${_TAG_ENTRIES} -gt 0 ]"

		# Verify tags are not showing "(unknown)" file paths
		! grep -q "(unknown)" shtracer_output/output.md
		assertEquals "Tag index should not show unknown file paths" 0 $?
	)
}

##
# @brief Test tag extraction with CRLF line endings (Windows compatibility)
# @tag @IT5.1@
test_crlf_tag_extraction() {
	(
		# Arrange
		cd "${SCRIPT_DIR%/}/testdata/crlf_test" || exit 1
		rm -rf shtracer_output/

		# Act - run shtracer on CRLF input files
		"${SHTRACER_BIN}" ./config_crlf.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert - should successfully extract tags despite CRLF
		assertEquals "Should extract tags from CRLF files" 0 "${_EXIT_CODE}"

		# Verify tags were extracted
		test -f shtracer_output/tags/04_tag_table
		assertEquals "Tag table should be created" 0 $?

		# Check that tags from CRLF files are present
		grep -q "@REQ1@" shtracer_output/tags/04_tag_table
		assertEquals "Should extract @REQ1@ from CRLF file" 0 $?

		grep -q "@ARC1@" shtracer_output/tags/04_tag_table
		assertEquals "Should extract @ARC1@ from CRLF file" 0 $?
	)
}

##
# @brief Test that output files have LF-only line endings (no CRLF)
# @tag @IT5.2@
test_crlf_output_files_lf_only() {
	(
		# Arrange
		cd "${SCRIPT_DIR%/}/testdata/crlf_test" || exit 1
		rm -rf shtracer_output/

		# Act
		"${SHTRACER_BIN}" ./config_crlf.md --debug >/dev/null 2>&1

		# Assert - all output files must be LF-only (no CRLF)
		# Check tag table
		if [ -f shtracer_output/tags/04_tag_table ]; then
			! file shtracer_output/tags/04_tag_table | grep -q "CRLF"
			assertEquals "Tag table should have LF-only line endings" 0 $?
		fi

		# Check all tag files
		for tagfile in shtracer_output/tags/*; do
			if [ -f "$tagfile" ]; then
				! file "$tagfile" | grep -q "CRLF"
				assertEquals "Tag file $tagfile should have LF-only endings" 0 $?
			fi
		done
	)
}

##
# @brief Test JSON output has no CRLF line endings
# @tag @IT5.3@
test_crlf_json_output_lf_only() {
	(
		# Arrange
		cd "${SCRIPT_DIR%/}/testdata/crlf_test" || exit 1
		rm -rf shtracer_output/

		# Act
		"${SHTRACER_BIN}" ./config_crlf.md --debug >/dev/null 2>&1

		# Assert - JSON output must be LF-only
		test -f shtracer_output/output.json
		assertEquals "JSON output should exist" 0 $?

		! file shtracer_output/output.json | grep -q "CRLF"
		assertEquals "JSON output should have LF-only line endings" 0 $?

		# Verify JSON is valid (no stray \r characters)
		! grep -q "$(printf '\r')" shtracer_output/output.json
		assertEquals "JSON should not contain carriage return characters" 0 $?
	)
}

##
# @brief Test HTML output has no CRLF line endings
# @tag @IT5.4@
test_crlf_html_output_lf_only() {
	(
		# Arrange
		_TEMP_HTML=$(mktemp "${TEST_ROOT}/html_output.XXXXXX.html")

		# Act
		"${SHTRACER_BIN}" "${SCRIPT_DIR%/}/testdata/crlf_test/config_crlf.md" --html >"$_TEMP_HTML" 2>/dev/null
		_EXIT_CODE=$?

		# Assert
		assertEquals "HTML generation should succeed" 0 "$_EXIT_CODE"

		# HTML output must be LF-only
		! file "$_TEMP_HTML" | grep -q "CRLF"
		assertEquals "HTML output should have LF-only line endings" 0 $?

		# Verify HTML doesn't have \r characters
		! grep -q "$(printf '\r')" "$_TEMP_HTML"
		assertEquals "HTML should not contain carriage return characters" 0 $?

		# Clean up
		rm -f "$_TEMP_HTML"
	)
}

##
# @brief Test Markdown output has no CRLF line endings
# @tag @IT5.5@
test_crlf_markdown_output_lf_only() {
	(
		# Arrange
		_TEMP_MD=$(mktemp "${TEST_ROOT}/md_output.XXXXXX.md")

		# Act
		"${SHTRACER_BIN}" "${SCRIPT_DIR%/}/testdata/crlf_test/config_crlf.md" --markdown >"$_TEMP_MD" 2>/dev/null
		_EXIT_CODE=$?

		# Assert
		assertEquals "Markdown generation should succeed" 0 "$_EXIT_CODE"

		# Markdown output must be LF-only
		! file "$_TEMP_MD" | grep -q "CRLF"
		assertEquals "Markdown output should have LF-only line endings" 0 $?

		# Verify Markdown doesn't have \r characters
		! grep -q "$(printf '\r')" "$_TEMP_MD"
		assertEquals "Markdown should not contain carriage return characters" 0 $?

		# Clean up
		rm -f "$_TEMP_MD"
	)
}

##
# @brief Test handling of mixed CRLF/LF line endings in same file
# @tag @IT5.6@
test_crlf_mixed_line_endings() {
	(
		# Arrange
		cd "${SCRIPT_DIR%/}/testdata/crlf_test" || exit 1
		rm -rf shtracer_output/

		# Update config to use absolute path to mixed file
		cat >config_mixed.md <<EOF
## Requirement
* **PATH**: "${SCRIPT_DIR%/}/testdata/crlf_test/mixed_endings.md"
* **TAG FORMAT**: \`@REQ[0-9\.]+@\`
* **TAG LINE FORMAT**: \`<!--.*-->\`
EOF

		# Act
		"${SHTRACER_BIN}" ./config_mixed.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert - should handle mixed line endings
		assertEquals "Should handle mixed CRLF/LF line endings" 0 "${_EXIT_CODE}"

		# Verify tag was extracted
		if [ -f shtracer_output/tags/04_tag_table ]; then
			grep -q "@REQ3@" shtracer_output/tags/04_tag_table
			assertEquals "Should extract tag from mixed line ending file" 0 $?
		fi

		# Clean up
		rm -f config_mixed.md
	)
}

##
# @brief Test absolute path resolution
# @tag @IT6.1@
test_path_absolute_paths() {
	(
		# Arrange
		_TEST_DIR="${SCRIPT_DIR%/}/testdata/path_resolution"
		_ABS_PATH="$(cd "$_TEST_DIR" && pwd)/requirements.md"

		cat >"${_TEST_DIR}/config_abs.md" <<EOF
## Requirement
* **PATH**: "${_ABS_PATH}"
* **TAG FORMAT**: \`@REQ[0-9\.]+@\`
* **TAG LINE FORMAT**: \`<!--.*-->\`
EOF

		cd "${_TEST_DIR}" || exit 1
		rm -rf shtracer_output/

		# Act
		"${SHTRACER_BIN}" ./config_abs.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert
		assertEquals "Should handle absolute paths" 0 "${_EXIT_CODE}"

		grep -q "@REQ1@" shtracer_output/tags/04_tag_table
		assertEquals "Should extract tag from absolute path" 0 $?

		# Clean up
		rm -f config_abs.md
	)
}

##
# @brief Test relative path resolution (., .., ../../)
# @tag @IT6.2@
test_path_relative_paths() {
	(
		# Arrange
		_TEST_DIR="${SCRIPT_DIR%/}/testdata/path_resolution"

		cat >"${_TEST_DIR}/config_rel.md" <<'EOF'
## Requirement
* **PATH**: "./requirements.md"
* **TAG FORMAT**: `@REQ[0-9\.]+@`
* **TAG LINE FORMAT**: `<!--.*-->`
EOF

		cd "${_TEST_DIR}" || exit 1
		rm -rf shtracer_output/

		# Act
		"${SHTRACER_BIN}" ./config_rel.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert
		assertEquals "Should handle relative paths" 0 "${_EXIT_CODE}"

		grep -q "@REQ1@" shtracer_output/tags/04_tag_table
		assertEquals "Should extract tag from relative path" 0 $?

		# Clean up
		rm -f config_rel.md
	)
}

##
# @brief Test paths with spaces
# @tag @IT6.3@
test_path_with_spaces() {
	(
		# Arrange
		_TEST_DIR="${SCRIPT_DIR%/}/testdata/path_resolution"

		cat >"${_TEST_DIR}/config_spaces.md" <<'EOF'
## Requirement
* **PATH**: "./my documents"
* **TAG FORMAT**: `@REQ[0-9\.]+@`
* **TAG LINE FORMAT**: `<!--.*-->`
* **EXTENSION FILTER**: "*.md"
EOF

		cd "${_TEST_DIR}" || exit 1
		rm -rf shtracer_output/

		# Act
		"${SHTRACER_BIN}" ./config_spaces.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert
		assertEquals "Should handle paths with spaces" 0 "${_EXIT_CODE}"

		grep -q "@REQ2@" shtracer_output/tags/04_tag_table
		assertEquals "Should extract tag from path with spaces" 0 $?

		# Clean up
		rm -f config_spaces.md
	)
}

##
# @brief Test paths with special characters ($, parentheses)
# @tag @IT6.4@
test_path_with_special_chars() {
	(
		# Arrange
		_TEST_DIR="${SCRIPT_DIR%/}/testdata/path_resolution"

		cat >"${_TEST_DIR}/config_special.md" <<'EOF'
## Requirement
* **PATH**: "./special$chars"
* **TAG FORMAT**: `@REQ[0-9\.]+@`
* **TAG LINE FORMAT**: `<!--.*-->`
* **EXTENSION FILTER**: "*.md"
EOF

		cd "${_TEST_DIR}" || exit 1
		rm -rf shtracer_output/

		# Act
		"${SHTRACER_BIN}" ./config_special.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert
		assertEquals "Should handle paths with special chars" 0 "${_EXIT_CODE}"

		grep -q "@REQ3@" shtracer_output/tags/04_tag_table
		assertEquals "Should extract tag from path with special chars" 0 $?

		# Clean up
		rm -f config_special.md
	)
}

##
# @brief Test config file accessed via symlink
# @tag @IT6.5@
test_path_config_via_symlink() {
	(
		# Arrange
		_TEST_DIR="${SCRIPT_DIR%/}/testdata/path_resolution"

		cat >"${_TEST_DIR}/config_real.md" <<'EOF'
## Requirement
* **PATH**: "./requirements.md"
* **TAG FORMAT**: `@REQ[0-9\.]+@`
* **TAG LINE FORMAT**: `<!--.*-->`
EOF

		cd "${_TEST_DIR}" || exit 1
		rm -rf shtracer_output/
		ln -sf config_real.md config_symlink.md

		# Act
		"${SHTRACER_BIN}" ./config_symlink.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert
		assertEquals "Should handle config via symlink" 0 "${_EXIT_CODE}"

		grep -q "@REQ1@" shtracer_output/tags/04_tag_table
		assertEquals "Should extract tag when config is symlink" 0 $?

		# Clean up
		rm -f config_real.md config_symlink.md
	)
}

##
# @brief Test source files accessed via symlink
# @tag @IT6.6@
test_path_source_file_symlink() {
	(
		# Arrange
		_TEST_DIR="${SCRIPT_DIR%/}/testdata/path_resolution"

		cd "${_TEST_DIR}" || exit 1
		rm -rf shtracer_output/
		ln -sf requirements.md requirements_link.md

		cat >config_srclink.md <<'EOF'
## Requirement
* **PATH**: "./requirements_link.md"
* **TAG FORMAT**: `@REQ[0-9\.]+@`
* **TAG LINE FORMAT**: `<!--.*-->`
EOF

		# Act
		"${SHTRACER_BIN}" ./config_srclink.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert
		assertEquals "Should handle source file symlink" 0 "${_EXIT_CODE}"

		grep -q "@REQ1@" shtracer_output/tags/04_tag_table
		assertEquals "Should extract tag from symlinked source" 0 $?

		# Clean up
		rm -f requirements_link.md config_srclink.md
	)
}

##
# @brief Test error handling for non-existent paths
# @tag @IT6.7@
test_path_nonexistent_file() {
	(
		# Arrange
		_TEST_DIR="${SCRIPT_DIR%/}/testdata/path_resolution"

		cat >"${_TEST_DIR}/config_nofile.md" <<'EOF'
## Requirement
* **PATH**: "./nonexistent.md"
* **TAG FORMAT**: `@REQ[0-9\.]+@`
* **TAG LINE FORMAT**: `<!--.*-->`
EOF

		cd "${_TEST_DIR}" || exit 1
		rm -rf shtracer_output/

		# Act
		"${SHTRACER_BIN}" ./config_nofile.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert - should fail with error code 11 (no tags found) when file doesn't exist
		assertEquals "Should return error for nonexistent files" 11 "${_EXIT_CODE}"

		# Clean up
		rm -f config_nofile.md
	)
}

##
# @brief Test very long path (PATH_MAX boundary testing)
# @tag @IT6.8@
test_path_very_long_path() {
	(
		# Arrange
		_TEST_DIR="${SCRIPT_DIR%/}/testdata/path_resolution"

		# Create nested directory structure (not too deep to avoid issues)
		_LONG_PATH="very/long/path/with/many/nested/directories/for/testing"
		mkdir -p "${_TEST_DIR}/${_LONG_PATH}"

		cat >"${_TEST_DIR}/${_LONG_PATH}/deep.md" <<'EOF'
<!-- @REQ4@ -->
## Deep Path Test
EOF

		cat >"${_TEST_DIR}/config_longpath.md" <<EOF
## Requirement
* **PATH**: "./${_LONG_PATH}/deep.md"
* **TAG FORMAT**: \`@REQ[0-9\.]+@\`
* **TAG LINE FORMAT**: \`<!--.*-->\`
EOF

		cd "${_TEST_DIR}" || exit 1
		rm -rf shtracer_output/

		# Act
		"${SHTRACER_BIN}" ./config_longpath.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert
		assertEquals "Should handle long paths" 0 "${_EXIT_CODE}"

		grep -q "@REQ4@" shtracer_output/tags/04_tag_table
		assertEquals "Should extract tag from long path" 0 $?

		# Clean up
		rm -rf very/
		rm -f config_longpath.md
	)
}

# shellcheck source=shunit2/shunit2
. "${TEST_ROOT%/}/shunit2/shunit2"
