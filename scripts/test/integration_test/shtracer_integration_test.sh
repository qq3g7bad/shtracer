#!/bin/sh

# Integration tests for shtracer
# Tests end-to-end functionality with real configuration and data

SCRIPT_DIR=$(CDPATH='' cd -- "$(dirname -- "$0")" 2>/dev/null && pwd -P)
TEST_ROOT=${TEST_ROOT:-$(CDPATH='' cd -- "${SCRIPT_DIR%/}/.." 2>/dev/null && pwd -P)}
SHTRACER_ROOT_DIR=${SHTRACER_ROOT_DIR:-$(CDPATH='' cd -- "${TEST_ROOT%/}/../.." 2>/dev/null && pwd -P)}

SHTRACER_BIN="${SHTRACER_ROOT_DIR%/}/shtracer"
SHTRACER_VIEWER="${SHTRACER_ROOT_DIR%/}/scripts/main/shtracer_html_viewer.sh"
TEST_DATA_DIR="${SCRIPT_DIR%/}/testdata"
ANSWER_DIR="${SCRIPT_DIR%/}/testdata/expected"

##
# @brief
#
oneTimeSetUp() {
	echo "----------------------------------------"
	echo " INTEGRATION TEST : $0"
	echo "----------------------------------------"
}

##
# @brief  SetUp function for each test
#
setUp() {
	set +u
	cd "${TEST_DATA_DIR}" || exit 1
	# Clean up any previous output
	rm -rf output/
}

##
# @brief TearDown function for each test
#
tearDown() {
	# Clean up output after each test
	rm -rf "${TEST_DATA_DIR}/shtracer_output/"
}

##
# @brief  Integration test for normal mode
# @tag    @IT1.1@ (FROM: @UT1.18@)
test_integration_normal_mode() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		"${SHTRACER_BIN}" ./config_integration.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Shtracer should exit successfully" 0 "${_EXIT_CODE}"

		# Check output files exist
		assertTrue "Config table should exist" "[ -f shtracer_output/config/01_config_table ]"
		assertTrue "Tags file should exist" "[ -f shtracer_output/tags/01_tags ]"
		assertTrue "Tag table should exist" "[ -f shtracer_output/tags/04_tag_table ]"
		assertTrue "JSON output should exist" "[ -f shtracer_output/output.json ]"
		assertTrue "HTML should not be generated by backend" "[ ! -f shtracer_output/output.html ]"

		# Verify tag table content
		# Note: String comparison may fail on Windows due to CRLF vs LF differences
		# Skip exact match test on Windows, but verify basic structure
		_TAG_TABLE=$(cat shtracer_output/tags/04_tag_table)
		_EXPECTED=$(cat "${ANSWER_DIR}/tag_table_expected.txt")

		# Normalize line endings for cross-platform compatibility
		_TAG_TABLE_NORM=$(printf '%s' "${_TAG_TABLE}" | tr -d '\r')
		_EXPECTED_NORM=$(printf '%s' "${_EXPECTED}" | tr -d '\r')

		assertEquals "Tag table should match expected output" "${_EXPECTED_NORM}" "${_TAG_TABLE_NORM}"

		# Generate HTML via viewer (stdin JSON -> stdout HTML)
		"${SHTRACER_VIEWER}" <shtracer_output/output.json >shtracer_output/output.html
		assertEquals "Viewer should exit successfully" 0 $?
		assertTrue "HTML output should exist" "[ -f shtracer_output/output.html ]"

		# Check HTML is valid (contains basic structure)
		grep -q "<!DOCTYPE html>" shtracer_output/output.html
		assertEquals "HTML should have DOCTYPE" 0 $?

		grep -q "<table" shtracer_output/output.html
		assertEquals "HTML should contain table" 0 $?

		# Check D3.js and Sankey elements
		grep -q "d3js.org" shtracer_output/output.html
		assertEquals "HTML should include D3.js" 0 $?

		grep -q "sankey-diagram" shtracer_output/output.html
		assertEquals "HTML should contain Sankey diagram container" 0 $?

		# Single-file: assets should be inlined
		grep -q "const files =" shtracer_output/output.html
		assertEquals "HTML should inline show_text.js data" 0 $?
		grep -q "traceabilityData" shtracer_output/output.html
		assertEquals "HTML should include embedded JSON" 0 $?

		# Check JSON structure (v0.2.0 format)
		grep -q '"metadata"' shtracer_output/output.json
		assertEquals "JSON should contain metadata" 0 $?
		grep -q '"files"' shtracer_output/output.json
		assertEquals "JSON should contain files" 0 $?
		grep -q '"layers"' shtracer_output/output.json
		assertEquals "JSON should contain layers" 0 $?
		grep -q '"trace_tags"' shtracer_output/output.json
		assertEquals "JSON should contain trace_tags" 0 $?
		grep -q '"chains"' shtracer_output/output.json
		assertEquals "JSON should contain chains" 0 $?
		grep -q '"health"' shtracer_output/output.json
		assertEquals "JSON should contain health" 0 $?
	)
}

##
# @brief  Output directory should be removed on normal exit (non-debug)
# @tag    @IT1.cleanup.1@
test_integration_cleanup_normal_exit() {
	(
		cd "${TEST_DATA_DIR}" || exit 1
		rm -rf shtracer_output/

		"${SHTRACER_BIN}" ./config_integration.md >/dev/null 2>&1
		_EXIT_CODE=$?
		assertEquals "Shtracer should exit successfully" 0 "${_EXIT_CODE}"
		assertFalse "Output dir should be removed on normal exit" "[ -d shtracer_output ]"
	)
}

##
# @brief  Integration test for --html (stdout HTML)
# @tag    @IT1.1a@ (FROM: @UT1.18@)
test_integration_html_option() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1
		rm -rf output
		mkdir -p output

		# Act -------------
		"${SHTRACER_BIN}" ./config_integration.md --debug --html >output/output.html 2>/dev/null
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Shtracer --html should exit successfully" 0 "${_EXIT_CODE}"
		assertTrue "JSON output should exist" "[ -f shtracer_output/output.json ]"
		assertTrue "HTML output should exist" "[ -f output/output.html ]"
		grep -q "<!DOCTYPE html>" output/output.html
		assertEquals "HTML should have DOCTYPE" 0 $?
		grep -q "traceabilityData" output/output.html
		assertEquals "HTML should include embedded JSON" 0 $?
	)
}

##
# @brief  Integration test for verify mode
# @tag    @IT1.2@ (FROM: @UT1.18@)
test_integration_verify_mode() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		_OUTPUT=$("${SHTRACER_BIN}" ./config_integration.md --debug -v 2>&1)
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Verify mode should exit successfully with valid data" 0 "${_EXIT_CODE}"

		# HTML should NOT be generated in verify mode
		assertFalse "HTML should not exist in verify mode" "[ -f shtracer_output/output.html ]"

		# Tag table should still be generated
		assertTrue "Tag table should exist in verify mode" "[ -f shtracer_output/tags/04_tag_table ]"
	)
}

##
# @brief  Integration test for change mode
# @tag    @IT1.3@ (FROM: @UT1.18@)
test_integration_change_mode() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Create a temporary copy of the test file
		cp req_sample.md req_sample_temp.md

		# Act -------------
		# Create a simple config that points to the temp file
		cat >config_temp.md <<'EOF'
# Temp Config

## Requirements

* **PATH**: "./req_sample_temp.md"
  * **BRIEF**: "Temporary requirements"
  * **TAG FORMAT**: `@REQ[0-9\.]+@`
  * **TAG LINE FORMAT**: `<!--.*-->`
  * **TAG-TITLE OFFSET**: 1
EOF

		"${SHTRACER_BIN}" ./config_temp.md -c "@REQ1.1@" "@REQ2.1@" >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Change mode should exit successfully" 0 "${_EXIT_CODE}"

		# Check that the tag was changed
		grep -q "@REQ2.1@" req_sample_temp.md
		assertEquals "Tag should be changed to @REQ2.1@" 0 $?

		grep -q "@REQ1.1@" req_sample_temp.md
		assertNotEquals "Original tag @REQ1.1@ should not exist" 0 $?

		# Clean up
		rm -f req_sample_temp.md config_temp.md
	)
}

##
# @brief  Integration test for multi-file traceability
# @tag    @IT1.4@ (FROM: @UT1.18@)
test_integration_multiple_files() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		"${SHTRACER_BIN}" ./config_integration.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Multi-file test should exit successfully" 0 "${_EXIT_CODE}"

		_TAG_TABLE=$(cat shtracer_output/tags/04_tag_table)

		# Verify complete traceability chains exist
		echo "${_TAG_TABLE}" | grep -q "@REQ1.1@ @ARC1.1@ @IMP1.1@"
		assertEquals "Complete chain REQ->ARC->IMP should exist for requirement 1.1" 0 $?

		echo "${_TAG_TABLE}" | grep -q "@REQ1.2@ @ARC1.2@ @IMP1.2@"
		assertEquals "Complete chain REQ->ARC->IMP should exist for requirement 1.2" 0 $?

		echo "${_TAG_TABLE}" | grep -q "@REQ1.3@ @ARC1.3@ @IMP1.3@"
		assertEquals "Complete chain REQ->ARC->IMP should exist for requirement 1.3" 0 $?

		# Count total chains
		_CHAIN_COUNT=$(echo "${_TAG_TABLE}" | wc -l)
		assertEquals "Should have exactly 3 traceability chains" 3 "${_CHAIN_COUNT}"
	)
}

##
# @brief  Output directory should be removed on signal (non-debug)
# @tag    @IT1.cleanup.2@
test_integration_cleanup_sigint() {
	cd "${TEST_DATA_DIR}" || exit 1
	rm -rf shtracer_output/

	SHTRACER_TEST_HOLD_SECS=10 "${SHTRACER_BIN}" ./config_integration.md >/dev/null 2>&1 &
	_PID=$!

	# Wait (up to ~5s) for output dir to appear
	_i=0
	while [ $_i -lt 5 ] && [ ! -d shtracer_output ]; do
		sleep 1
		_i=$((_i + 1))
	done
	assertTrue "Output dir should exist before SIGINT" "[ -d shtracer_output ]"

	kill -TERM "${_PID}" >/dev/null 2>&1 || :
	wait "${_PID}"
	_RC=$?
	assertNotEquals "Process should not exit 0 on signal" 0 "${_RC}"
	assertFalse "Output dir should be removed on signal" "[ -d shtracer_output ]"
}

##
# @brief  Integration test for error handling
# @tag    @IT1.5@ (FROM: @UT1.18@)
test_integration_error_handling() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Create config with non-existent path
		cat >config_error.md <<'EOF'
# Error Config

## NonExistent

* **PATH**: "./non_existent_file.md"
  * **BRIEF**: "This file does not exist"
  * **TAG FORMAT**: `@TEST[0-9\.]+@`
  * **TAG LINE FORMAT**: `<!--.*-->`
  * **TAG-TITLE OFFSET**: 1
EOF

		# Act -------------
		_OUTPUT=$("${SHTRACER_BIN}" ./config_error.md 2>&1)
		_EXIT_CODE=$?

		# Assert ----------
		assertNotEquals "Shtracer should exit with error for non-existent file" 0 "${_EXIT_CODE}"

		# Error message should be present
		echo "${_OUTPUT}" | grep -q "error\|Error\|No linked tags"
		assertEquals "Error message should be present" 0 $?

		# Clean up
		rm -f config_error.md
	)
}

##
# @brief  Integration test for default JSON export
# @tag    @IT2.1@ (FROM: @UT1.18@)
test_integration_json_export() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		_OUTPUT=$("${SHTRACER_BIN}" ./config_integration.md 2>&1)
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Shtracer should exit successfully with default JSON output" 0 "${_EXIT_CODE}"

		# Verify JSON is output to stdout by default (v0.2.0 format)
		echo "${_OUTPUT}" | grep -q '"metadata"'
		assertEquals "JSON should contain metadata" 0 $?

		echo "${_OUTPUT}" | grep -q '"trace_tags"'
		assertEquals "JSON should contain trace_tags" 0 $?

		echo "${_OUTPUT}" | grep -q '"files"'
		assertEquals "JSON should contain files" 0 $?

		echo "${_OUTPUT}" | grep -q '"chains"'
		assertEquals "JSON should contain chains" 0 $?

		# HTML should NOT be generated by default
		assertTrue "HTML should not be generated by default" "[ ! -f output/output.html ]"
	)
}

##
# @brief  Integration test for summary export
test_integration_summary_export() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		_OUTPUT=$("${SHTRACER_BIN}" ./config_integration.md --summary 2>&1)
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Shtracer should exit successfully with summary" 0 "${_EXIT_CODE}"

		# Basic format checks
		echo "${_OUTPUT}" | grep -q "^Requirement$\|^Architecture$\|^Implementation$\|^Unit test$\|^Integration test$"
		assertEquals "Summary should contain layer headers" 0 $?
		echo "${_OUTPUT}" | grep -q "^  upstream: \|^  downstream: "
		assertEquals "Summary should contain upstream/downstream lines" 0 $?
		echo "${_OUTPUT}" | grep -q "%$\|<1%"
		assertEquals "Summary should contain percentage tokens" 0 $?

		# HTML/JSON should NOT be generated in summary mode
		assertTrue "HTML should not be generated with --summary" "[ ! -f output/output.html ]"
		assertTrue "JSON should not be generated with --summary" "[ ! -f output/output.json ]"
	)
}

##
# @brief  Integration test for --html before config (flexible order)
# @tag    @IT1.6@ (FROM: @UT1.25@)
test_integration_html_flexible_order() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1
		_OUTPUT_HTML="${SHUNIT_TMPDIR%/}/shtracer_html_flexible_order.html"
		rm -f "${_OUTPUT_HTML}"

		# Act -------------
		# New order: --html first
		"${SHTRACER_BIN}" --html ./config_integration.md >"${_OUTPUT_HTML}" 2>/dev/null
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "HTML export with --html before config should succeed" 0 "${_EXIT_CODE}"

		assertTrue "HTML output should exist" "[ -f '${_OUTPUT_HTML}' ]"

		# Check HTML is valid
		grep -q "<!DOCTYPE html>" "${_OUTPUT_HTML}"
		assertEquals "HTML should have DOCTYPE" 0 $?

		grep -q "<table" "${_OUTPUT_HTML}"
		assertEquals "HTML should contain table" 0 $?

		grep -q "d3js.org" "${_OUTPUT_HTML}"
		assertEquals "HTML should include D3.js" 0 $?
	)
}

##
# @brief  Integration test for -v before config (flexible order)
# @tag    @IT1.7@ (FROM: @UT1.26@)
test_integration_verify_flexible_order() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		# New order: -v first
		_OUTPUT=$("${SHTRACER_BIN}" -v ./config_integration.md 2>&1)
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Verify mode with -v before config should succeed" 0 "${_EXIT_CODE}"

		# Output should be empty on success (no duplicates/isolated tags)
		# or should contain verification messages if issues found
		# For this test data, we expect success with minimal output
	)
}

##
# @brief  Test that cross-reference matrix files are generated
# @tag    @IT1.8@ (FROM: @IMP4.4@)
test_cross_ref_matrix_files_generated() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		"${SHTRACER_BIN}" ./config_integration.md --debug >/dev/null 2>&1
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Shtracer should exit successfully" 0 "${_EXIT_CODE}"

		# Check that cross-reference matrix files exist
		_MATRIX_FILES=$(find shtracer_output/tags -name "06_cross_ref_matrix_*" 2>/dev/null | wc -l)
		assertTrue "At least one cross-reference matrix file should exist" "[ ${_MATRIX_FILES} -gt 0 ]"

		# Verify matrix file format
		_FIRST_MATRIX=$(find shtracer_output/tags -name "06_cross_ref_matrix_*" 2>/dev/null | head -1)
		if [ -n "${_FIRST_MATRIX}" ]; then
			grep -q "^\[METADATA\]" "${_FIRST_MATRIX}"
			assertEquals "Matrix file should have METADATA section" 0 $?

			grep -q "^\[MATRIX\]" "${_FIRST_MATRIX}"
			assertEquals "Matrix file should have MATRIX section" 0 $?
		fi
	)
}

##
# @brief  Test that HTML viewer displays cross-reference tables
# @tag    @IT1.9@ (FROM: @IMP4.4@)
test_html_cross_ref_tables() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1

		# Act -------------
		"${SHTRACER_BIN}" ./config_integration.md --debug >/dev/null 2>&1
		"${SHTRACER_VIEWER}" <shtracer_output/output.json >shtracer_output/output.html 2>&1

		# Assert ----------
		assertTrue "HTML output should exist" "[ -f shtracer_output/output.html ]"

		# Check for cross-reference matrix tabs
		_XREF_TABS=$(grep -c "matrix-tab" shtracer_output/output.html || echo "0")
		assertTrue "HTML should contain cross-reference matrix tabs" "[ ${_XREF_TABS} -gt 0 ]"

		# Verify that tables are not empty (should contain matrix-table class)
		grep -q "matrix-table" shtracer_output/output.html
		assertEquals "HTML should contain cross-reference matrix tables" 0 $?
	)
}

##
# @brief  Test that markdown viewer shows populated tag index
# @tag    @IT1.10@ (FROM: @IMP4.3.10.2@)
test_markdown_tag_index() {
	(
		# Arrange ---------
		cd "${TEST_DATA_DIR}" || exit 1
		mkdir -p shtracer_output

		# Act -------------
		"${SHTRACER_BIN}" --markdown ./config_integration.md >shtracer_output/output.md 2>&1
		_EXIT_CODE=$?

		# Assert ----------
		assertEquals "Markdown mode should exit successfully" 0 "${_EXIT_CODE}"

		# Check for tag index section
		grep -q "^## Tag Index" shtracer_output/output.md
		assertEquals "Markdown should have Tag Index section" 0 $?

		# Verify that tag index has actual tag entries (not just "****")
		_TAG_ENTRIES=$(grep -c "^- @" shtracer_output/output.md || echo "0")
		assertTrue "Tag index should have actual tag entries" "[ ${_TAG_ENTRIES} -gt 0 ]"

		# Verify tags are not showing "(unknown)" file paths
		! grep -q "(unknown)" shtracer_output/output.md
		assertEquals "Tag index should not show unknown file paths" 0 $?
	)
}

# shellcheck source=shunit2/shunit2
. "${TEST_ROOT%/}/shunit2/shunit2"
