#!/bin/sh

##
# @defgroup Exit codes for CI/CD integration
# @{
# Exit codes help CI/CD systems identify specific failure types
#
# SUCCESS
# shellcheck disable=SC2034  # Used for documentation
EXIT_SUCCESS=0
#
# USAGE ERRORS (1-9)
EXIT_USAGE=1            # Invalid arguments or usage
EXIT_CONFIG_NOT_FOUND=2 # Config file not found
# shellcheck disable=SC2034  # Used for documentation
EXIT_CONFIG_INVALID=3 # Config file format invalid
#
# PROCESSING ERRORS (10-19)
EXIT_EXTRACT_TAGS_FAILED=10 # Failed to extract tags
EXIT_MAKE_TABLE_FAILED=11   # Failed to create tag table
EXIT_MAKE_JSON_FAILED=12    # Failed to generate JSON
EXIT_VIEWER_FAILED=13       # Viewer script execution failed
#
# VERIFICATION ERRORS (20-29)
EXIT_ISOLATED_TAGS=20  # Found isolated tags (no downstream references)
EXIT_DUPLICATE_TAGS=21 # Found duplicate tags (highest priority)
EXIT_DANGLING_TAGS=22  # Found dangling FROM tag references
#
# SYSTEM ERRORS (30-39)
EXIT_INTERNAL_ERROR=30   # Internal error (directory change, etc.)
EXIT_VIEWER_NOT_FOUND=31 # Viewer script not found
##
# @}
#

##
# @defgroup Global variables
# @{

CONFIG_PATH=''
SHTRACER_MODE='NORMAL'
BEFORE_TAG=''
AFTER_TAG=''
EXPORT_SUMMARY='false'
EXPORT_HTML='false'
EXPORT_MARKDOWN='false'
SHTRACER_DEBUG='false'
OUTPUT_DIR_DEFAULT_NAME='shtracer_output'
SHTRACER_SEPARATOR="<shtracer_separator>"
CURRENT_DIR="$(pwd)"
# Version information (single source of truth for version bumping)
SHTRACER_VERSION='0.1.4'
SCRIPT_DIR=${SCRIPT_DIR:-$(cd "$(dirname "$0")" && pwd)}

# Export variables used in external scripts
export NODATA_STRING="NONE"
OUTPUT_DIR="${OUTPUT_DIR:-}"
export OUTPUT_DIR
##
# @}
#

##
# @brief  Load helper functions
# @tag    @IMP1.1@ (FROM: @ARC1.2@)
load_functions() {
	_PREVIOUS_DIR="$(pwd)"
	cd "${SCRIPT_DIR}" || error_exit "$EXIT_INTERNAL_ERROR" "load_functions" "Cannot change current directory"

	_UTIL_SCRIPT_DIR="${SCRIPT_DIR}/scripts/main"
	export _UTIL_SCRIPT_DIR

	# shellcheck source=scripts/main/shtracer_util.sh
	. "./scripts/main/shtracer_util.sh"
	# shellcheck source=scripts/main/shtracer_func.sh
	. "./scripts/main/shtracer_func.sh"
	cd "${_PREVIOUS_DIR}" || error_exit "$EXIT_INTERNAL_ERROR" "load_functions" "Cannot change current directory"
}

##
# @brief  Print usage
# @tag    @IMP1.2@ (FROM: @ARC1.2@)
print_usage() {
	cat <<-USAGE 1>&2
		Usage: shtracer <configfile> [options]

		Options:
		  -c <old_tag> <new_tag>           Change mode: swap or rename trace target tags
		  -v, --verify                     Verify mode: detect duplicate or isolated tags
		  -t, --test                       Test mode: execute unit tests
		  --html                           Export a single HTML document to stdout (JSON -> viewer)
		  --markdown                       Export a print-friendly Markdown report to stdout (JSON -> markdown)
		  --summary                        Print traceability summary to stdout (direct links only)
		  --debug                          Keep ${OUTPUT_DIR} and output tag table to stderr
		  -h, --help                       Show this help message

		Examples:
		  1. Normal mode (JSON output)
		     $ ./shtracer ./sample/config.md
		     $ ./shtracer ./sample/config.md > output.json

		  2. Change mode (swap or rename tags)
		     $ ./shtracer -c old_tag new_tag ./sample/config.md

		  3. Verify mode (check for duplicate or isolated tags)
		     $ ./shtracer -v ./sample/config.md
		     $ ./shtracer --verify ./sample/config.md

		  4. Test mode
		     $ ./shtracer -t
		     $ ./shtracer --test

		  5. Summary mode
		     $ ./shtracer --summary ./sample/config.md

		  6. HTML mode
		     $ ./shtracer --html ./sample/config.md > output.html

		  7. Markdown mode
		     $ ./shtracer --markdown ./sample/config.md > report.md

		  8. Debug mode (JSON + tag table to stderr)
		     $ ./shtracer --debug ./sample/config.md > output.json

		Note:
		  - Arguments can be specified in any order.
		  - Only one option can be used at a time.

		Version:
		  - ${SHTRACER_VERSION}

		Exit Codes:
		  0   - Success
		  1   - Invalid usage or arguments
		  2   - Config file not found
		  3   - Config file format invalid
		  10  - Failed to extract tags
		  11  - Failed to create tag table
		  12  - Failed to generate JSON
		  13  - Viewer script execution failed
		  20  - Found isolated tags (verify mode)
		  21  - Found duplicate tags (verify mode - highest priority)
		  22  - Found dangling FROM tag references (verify mode)
		  30  - Internal error
		  31  - Viewer script not found

		  Note (verify mode): If multiple issues exist, all are reported to stderr
		                      but exit code reflects highest-priority error (21 > 22 > 20)

	USAGE
	exit "$EXIT_USAGE"
}

##
# @brief  Parse arguments with flexible ordering (two-pass algorithm)
# @tag    @IMP1.3@ (FROM: @ARC1.2@)
parse_arguments() {
	# Special case: single argument (help, version, test, or config only)
	if [ "$#" -eq 1 ]; then
		case "$1" in
			-h | -v | --verify | --help | --version)
				# Note: -v/--verify alone prints usage (backward compatibility)
				# -v/--verify with config file activates verify mode
				print_usage
				;;
			-t | --test)
				SHTRACER_MODE='TEST'
				return
				;;
			--html | --markdown | --summary)
				# These options require a config file
				error_exit "$EXIT_CONFIG_NOT_FOUND" "parse_arguments" "Config file required"
				;;
			-*)
				error_exit "$EXIT_USAGE" "parse_arguments" "Invalid argument"
				;;
			*)
				# Single argument: treat as config file
				_config_file="$1"
				SHTRACER_MODE='NORMAL'
				;;
		esac
	else
		# Multi-argument parsing: extract options and config file
		_opt_mode=""
		_opt_flag=""
		_export_flag=""
		_config_file=""
		_change_before=""
		_change_after=""
		_found_option=0

		while [ $# -gt 0 ]; do
			case "$1" in
				-v | --verify)
					_found_option=$((_found_option + 1))
					_opt_mode="VERIFY"
					_opt_flag="$1"
					shift
					;;
				-c)
					_found_option=$((_found_option + 1))
					_opt_mode="CHANGE"
					_opt_flag="-c"
					if [ $# -lt 3 ]; then
						error_exit "$EXIT_USAGE" "parse_arguments" "-c requires <before_tag> <after_tag>"
					fi
					shift
					_change_before="$1"
					shift
					_change_after="$1"
					shift
					;;
				--json)
					_found_option=$((_found_option + 1))
					_export_flag="--json"
					shift
					;;
				--html)
					_found_option=$((_found_option + 1))
					_export_flag="--html"
					shift
					;;
				--markdown)
					_found_option=$((_found_option + 1))
					_export_flag="--markdown"
					shift
					;;
				--summary)
					_found_option=$((_found_option + 1))
					_export_flag="--summary"
					shift
					;;
				--debug)
					SHTRACER_DEBUG='true'
					shift
					;;
				-*)
					error_exit "$EXIT_USAGE" "parse_arguments" "Invalid option: $1"
					;;
				*)
					# Non-option argument: assume config file
					if [ -z "$_config_file" ]; then
						_config_file="$1"
					else
						error_exit "$EXIT_USAGE" "parse_arguments" "Multiple config files specified"
					fi
					shift
					;;
			esac
		done

		# Validation: reject multiple simultaneous options
		if [ "$_found_option" -gt 1 ]; then
			error_exit "$EXIT_USAGE" "parse_arguments" "Multiple options not supported (use only one of: -v/--verify, -c, --html, --markdown, --summary)"
		fi

		# Validation: mode flags and export flags are mutually exclusive
		if [ -n "$_opt_flag" ] && [ -n "$_export_flag" ]; then
			error_exit "$EXIT_USAGE" "parse_arguments" "Cannot combine $_opt_flag with $_export_flag"
		fi

		# Set mode
		if [ -n "$_opt_mode" ]; then
			SHTRACER_MODE="$_opt_mode"
		else
			SHTRACER_MODE="NORMAL"
		fi

		# Set export flags
		case "$_export_flag" in
			--html)
				EXPORT_HTML='true'
				;;
			--markdown)
				EXPORT_MARKDOWN='true'
				;;
			--summary)
				EXPORT_SUMMARY='true'
				;;
		esac

		# Set change mode tags
		if [ "$SHTRACER_MODE" = "CHANGE" ]; then
			BEFORE_TAG="$_change_before"
			AFTER_TAG="$_change_after"
		fi
	fi

	# Validation: config file required for non-TEST modes
	if [ "$SHTRACER_MODE" != "TEST" ]; then
		if [ -z "$_config_file" ]; then
			error_exit "$EXIT_CONFIG_NOT_FOUND" "parse_arguments" "Config file required"
		fi

		# Check if config file exists
		if [ ! -r "$_config_file" ]; then
			error_exit "$EXIT_CONFIG_NOT_FOUND" "parse_arguments" "$_config_file does not exist"
		fi

		# Resolve to absolute path
		cd "$CURRENT_DIR" || error_exit "$EXIT_INTERNAL_ERROR" "parse_arguments" "Cannot change current directory"
		CONFIG_DIR="$(cd "$(dirname "$_config_file")" && pwd)"
		# OUTPUT_DIR override semantics:
		# - If unset/empty: use default name under CONFIG_DIR
		# - If contains '/': treat as path (absolute, or relative to CONFIG_DIR)
		# - Else: treat as directory name under CONFIG_DIR
		if [ -z "${OUTPUT_DIR:-}" ]; then
			OUTPUT_DIR="${CONFIG_DIR%/}/${OUTPUT_DIR_DEFAULT_NAME}/"
		else
			case "${OUTPUT_DIR}" in
				/*)
					OUTPUT_DIR="${OUTPUT_DIR%/}/"
					;;
				*/*)
					OUTPUT_DIR="${CONFIG_DIR%/}/${OUTPUT_DIR%/}/"
					;;
				*)
					OUTPUT_DIR="${CONFIG_DIR%/}/${OUTPUT_DIR%/}/"
					;;
			esac
		fi
		CONFIG_PATH="${CONFIG_DIR%/}/$(basename "$_config_file")"
		CONFIG_OUTPUT=$(check_configfile "$CONFIG_PATH")
	fi
}

_cleanup_output_dir() {
	# Never delete when debugging or when OUTPUT_DIR is empty/unsafe.
	if [ "${SHTRACER_DEBUG}" = 'true' ]; then
		return 0
	fi
	if [ -z "${OUTPUT_DIR}" ]; then
		return 0
	fi
	case "${OUTPUT_DIR}" in
		"/" | "")
			return 0
			;;
		*/output | */output/)
			: # ok
			;;
		*/shtracer_output | */shtracer_output/)
			: # ok
			;;
		*)
			# Safety: only delete known output dir names.
			return 0
			;;
	esac
	rm -rf -- "${OUTPUT_DIR}" >/dev/null 2>&1 || true
}

_install_cleanup_traps() {
	# Install once per process.
	if [ "${_SHTRACER_TRAPS_INSTALLED:-}" = 'true' ]; then
		return 0
	fi
	_SHTRACER_TRAPS_INSTALLED='true'

	trap '_cleanup_output_dir' EXIT
	trap 'trap - EXIT; _cleanup_output_dir; exit 130' INT
	trap 'trap - EXIT; _cleanup_output_dir; exit 143' TERM
	trap 'trap - EXIT; _cleanup_output_dir; exit 129' HUP
	trap 'trap - EXIT; _cleanup_output_dir; exit 131' QUIT

	# Optional test hook: delay after traps are installed.
	# (Used only by tests to reliably send SIGINT.)
	if [ -n "${SHTRACER_TEST_HOLD_SECS:-}" ]; then
		case "${SHTRACER_TEST_HOLD_SECS}" in
			*[!0-9]* | '') : ;;
			*)
				sleep "${SHTRACER_TEST_HOLD_SECS}" || true
				;;
		esac
	fi
}

##
# @brief  Main routine
# @tag    @IMP1.4@ (FROM: @ARC1.1@)
main_routine() {

	load_functions
	init_environment
	parse_arguments "$@"

	# Ensure output directory exists early in the process (normal/verify modes).
	if [ -n "${OUTPUT_DIR:-}" ] && [ "$SHTRACER_MODE" != 'CHANGE' ] && [ "$SHTRACER_MODE" != 'TEST' ]; then
		mkdir -p -- "${OUTPUT_DIR}" >/dev/null 2>&1 || true
	fi

	# Export mode for use in sub-functions
	export SHTRACER_MODE
	export EXPORT_SUMMARY
	export EXPORT_HTML
	export SHTRACER_DEBUG

	# Install cleanup traps after OUTPUT_DIR is resolved.
	if [ "$SHTRACER_MODE" != 'TEST' ]; then
		_install_cleanup_traps
	fi

	# Tag change mode
	if [ "$SHTRACER_MODE" = 'CHANGE' ]; then
		swap_tags "$CONFIG_OUTPUT" "$BEFORE_TAG" "$AFTER_TAG"
		_cleanup_output_dir
		return 0

	# Test mode
	elif [ "$SHTRACER_MODE" = 'TEST' ]; then
		sh -c "cd ${SCRIPT_DIR%/}/scripts/test/; ./run_all_tests.sh"
		return 0
	fi

	# Normal mode or Verify mode
	if ! _TAGS=$(extract_tags "$CONFIG_OUTPUT"); then
		error_exit "$EXIT_EXTRACT_TAGS_FAILED" "main_routine" "Error in extract_tags"
	fi
	if ! _TAG_TABLE_FILENAMES=$(make_tag_table "$_TAGS"); then
		error_exit "$EXIT_MAKE_TABLE_FAILED" "main_routine" "Error in make_tag_table"
	fi

	_TAG_TABLE_FILENAME=${_TAG_TABLE_FILENAMES%%"$SHTRACER_SEPARATOR"*}
	_VERIFICATION_FILENAME=${_TAG_TABLE_FILENAMES#*"$SHTRACER_SEPARATOR"}

	if [ "$SHTRACER_MODE" = 'NORMAL' ]; then
		# If --summary flag is specified, print summary to stdout and exit
		if [ "$EXPORT_SUMMARY" = 'true' ]; then
			_TAG_OUTPUT_DIR="${OUTPUT_DIR%/}/tags/"
			print_summary_direct_links "$_TAGS" "${_TAG_OUTPUT_DIR%/}/02_tag_pairs" "${_TAG_OUTPUT_DIR%/}/05_file_versions"
			_cleanup_output_dir
			return 0
		fi

		# Generate cross-reference intermediate files
		_TAG_OUTPUT_DIR="${OUTPUT_DIR%/}/tags/"
		_CONFIG_OUTPUT_DIR="${OUTPUT_DIR%/}/config/"
		if _XREF_DIR=$(make_cross_reference_tables \
			"${_CONFIG_OUTPUT_DIR%/}/01_config_table" \
			"${_TAG_OUTPUT_DIR%/}/01_tags" \
			"${_TAG_OUTPUT_DIR%/}/02_tag_pairs"); then
			# Generate Markdown output from intermediate files
			markdown_cross_reference "$_XREF_DIR" "$CONFIG_PATH" >/dev/null || {
				echo "[shtracer][warning]: Failed to generate markdown cross-reference tables" >&2
			}
		else
			echo "[shtracer][warning]: Failed to generate cross-reference intermediate files" >&2
		fi

		# Generate JSON (now mandatory for visualization)
		_TAG_OUTPUT_DIR="${OUTPUT_DIR%/}/tags/"
		_CONFIG_OUTPUT_DIR="${OUTPUT_DIR%/}/config/"
		if ! _JSON_OUTPUT_FILE=$(make_json \
			"$_TAGS" \
			"${_TAG_OUTPUT_DIR%/}/02_tag_pairs" \
			"${_TAG_OUTPUT_DIR%/}/03_tag_pairs_downstream" \
			"$_TAG_TABLE_FILENAME" \
			"${_CONFIG_OUTPUT_DIR%/}/01_config_table" \
			"$CONFIG_PATH" \
			"${_XREF_DIR:-}"); then
			error_exit "$EXIT_MAKE_JSON_FAILED" "main_routine" "Error in make_json"
		fi

		# If --html flag is specified, generate HTML to stdout via viewer and exit
		if [ "$EXPORT_HTML" = 'true' ]; then
			if [ ! -r "${SCRIPT_DIR%/}/scripts/main/shtracer_html_viewer.sh" ]; then
				error_exit "$EXIT_VIEWER_NOT_FOUND" "main_routine" "Viewer script not found: ${SCRIPT_DIR%/}/scripts/main/shtracer_html_viewer.sh"
			fi
			# Pass OUTPUT_DIR to viewer so it can access intermediate files (cross-reference matrices)
			# Strip carriage returns to ensure consistent LF-only line endings (fixes WSL/Windows CRLF issues)
			if ! OUTPUT_DIR="$OUTPUT_DIR" sh "${SCRIPT_DIR%/}/scripts/main/shtracer_html_viewer.sh" <"$_JSON_OUTPUT_FILE" | tr -d '\r'; then
				_cleanup_output_dir
				error_exit "$EXIT_VIEWER_FAILED" "main_routine" "Viewer script execution failed"
			fi
			_cleanup_output_dir
			return 0
		fi

		# If --markdown flag is specified, generate Markdown to stdout via markdown viewer and exit
		if [ "$EXPORT_MARKDOWN" = 'true' ]; then
			if [ ! -r "${SCRIPT_DIR%/}/scripts/main/shtracer_markdown_viewer.sh" ]; then
				error_exit "$EXIT_VIEWER_NOT_FOUND" "main_routine" "Markdown viewer script not found: ${SCRIPT_DIR%/}/scripts/main/shtracer_markdown_viewer.sh"
			fi
			# Pass OUTPUT_DIR to viewer for accessing intermediate files
			# Strip carriage returns to ensure consistent LF-only line endings (fixes WSL/Windows CRLF issues)
			if ! OUTPUT_DIR="$OUTPUT_DIR" sh "${SCRIPT_DIR%/}/scripts/main/shtracer_markdown_viewer.sh" <"$_JSON_OUTPUT_FILE" | tr -d '\r'; then
				_cleanup_output_dir
				error_exit "$EXIT_VIEWER_FAILED" "main_routine" "Markdown viewer script execution failed"
			fi
			_cleanup_output_dir
			return 0
		fi
	fi

	# Extract verification file paths
	_TAG_TABLE_ISOLATED=$(extract_field "$_VERIFICATION_FILENAME" 1 "$SHTRACER_SEPARATOR")
	_TAG_TABLE_DUPLICATED=$(extract_field "$_VERIFICATION_FILENAME" 2 "$SHTRACER_SEPARATOR")
	_TAG_TABLE_DANGLING=$(extract_field "$_VERIFICATION_FILENAME" 3 "$SHTRACER_SEPARATOR")

	# Print all detected errors to stderr (one line per error)
	print_verification_result "$_TAGS" "$_TAG_TABLE_ISOLATED" "$_TAG_TABLE_DUPLICATED" "$_TAG_TABLE_DANGLING"

	# Check if any issues were found
	_has_duplicates=false
	_has_dangling=false
	_has_isolated=false

	if ! _check_verification_file "$_TAG_TABLE_DUPLICATED" "duplicated"; then
		_has_duplicates=true
	fi
	if ! _check_verification_file "$_TAG_TABLE_DANGLING" "dangling"; then
		_has_dangling=true
	fi
	if ! _check_verification_file "$_TAG_TABLE_ISOLATED" "isolated"; then
		_has_isolated=true
	fi

	if [ "$SHTRACER_MODE" = 'VERIFY' ]; then
		_cleanup_output_dir
		# Exit on first error (priority order: duplicates → dangling → isolated)
		if [ "$_has_duplicates" = true ]; then
			error_exit "$EXIT_DUPLICATE_TAGS" "main_routine" "Verification failed: found duplicate tags"
		elif [ "$_has_dangling" = true ]; then
			error_exit "$EXIT_DANGLING_TAGS" "main_routine" "Verification failed: found dangling FROM tag references"
		elif [ "$_has_isolated" = true ]; then
			error_exit "$EXIT_ISOLATED_TAGS" "main_routine" "Verification failed: found isolated tags"
		else
			# No issues found
			return 0
		fi
	else
		# In normal mode, verification warnings don't cause failure
		# Output JSON even when verification warnings exist
		cat "$_JSON_OUTPUT_FILE"
		# Debug mode: also output tag table to stderr
		if [ "$SHTRACER_DEBUG" = 'true' ]; then
			echo "[shtracer][debug]: Tag table output:" >&2
			cat "$_TAG_TABLE_FILENAME" >&2
		fi
		_cleanup_output_dir
		# Print warning message for highest-priority issue (consistent with verify mode)
		if [ "$_has_duplicates" = true ]; then
			echo "[${0##*/}][warn][main_routine]: found duplicate tags" 1>&2
		elif [ "$_has_dangling" = true ]; then
			echo "[${0##*/}][warn][main_routine]: found dangling FROM tag references" 1>&2
		elif [ "$_has_isolated" = true ]; then
			echo "[${0##*/}][warn][main_routine]: found isolated tags" 1>&2
		fi
		# Exit with success in normal mode (warnings are informational only)
		return 0
	fi
}

case "$0" in
	*shtracer)
		main_routine "$@"
		;;
	*)
		:
		;;
esac
